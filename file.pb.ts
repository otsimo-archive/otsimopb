// Code generated by protoc-gen-js-fetch.
// DO NOT EDIT!

import * as apipb_messages from "./messages.pb";

export interface FileMetadata {
/**
Key is the unique name of the file in collection
*/
  key?: string;
/**
Collection of the file, value can be asset, gameid or userid
*/
  collection?: string;
/**
Labels of the file. Label fields cannot be "key", "collection" and "type"
*/
  labels?: { [key: string]: string };
		/**
Type is Mime Type of the file
*/
  type?: string;
/**
Checksum is MD5 of the file
*/
  checksum?: string;
/**
Owner of the file, if the value is empty means that its open to everyone
*/
  owner?: string;
/**
Url is the stored file url
*/
  url?: string;
}

export const FileMetadata_key = "key";
export const FileMetadata_collection = "collection";
export const FileMetadata_labels = "labels";
export const FileMetadata_type = "type";
export const FileMetadata_checksum = "checksum";
export const FileMetadata_owner = "owner";
export const FileMetadata_url = "url";
export interface UploadReq {
/**
Metadata list of upload files, keys have to be unique in the list
*/
  metadata?: FileMetadata[];
}

export const UploadReq_metadata = "metadata";
export interface UploadRes {
  uploadUrls?: { [key: string]: string };
		}

export const UploadRes_uploadUrls = "upload_urls";
export interface StoreSmallReq {
  metadata?: FileMetadata;
  data?: string;
}

export const StoreSmallReq_metadata = "metadata";
export const StoreSmallReq_data = "data";
export interface StoreRes {
  metadata?: FileMetadata;
}

export const StoreRes_metadata = "metadata";
export interface LookupReq {
/**
Selector the files. "key", "collection" and "type" also part of labels
*/
  selector?: apipb_messages.LabelSelector;
}

export const LookupReq_selector = "selector";
export interface LookupRes {
  metadata?: FileMetadata[];
}

export const LookupRes_metadata = "metadata";
export class FileService {
    private host:string;
    private headerEditors :any[]= [];
 /**
  * @param {string} url the service host url
  */
  constructor(url: string) {
    this.host = url;
    this.headerEditors=[];
  }

  addHeaderEditor(m: any) {
    this.headerEditors.push(m)
  }

  async requestStoreBig(uploadReq: UploadReq): Promise<UploadRes> {
	const _headers = new Headers();
	_headers.append("Content-Type", "application/json");
	for (let i = 0; i < this.headerEditors.length; ++i) {
	  this.headerEditors[i].edit(_headers);
	}
	const _url = new URL(`${this.host}/api/v1/file/big`);
	const _init = {
	  method: 'POST',
	  headers: _headers,
	  body: JSON.stringify(uploadReq),
	} as RequestInit;
	
	const _req = new Request(_url.toString(), _init);
	try {
	  const resp = await fetch(_req);
	  if (resp.status !== 200) {
        const rj = await resp.json();
        return Promise.reject(rj);
      }
	  return resp.json();
	} catch (err) {
	  return Promise.reject(err);
	}
  }

   
  async lookup(lookupReq: LookupReq): Promise<LookupRes> {
	const _headers = new Headers();
	_headers.append("Content-Type", "application/json");
	for (let i = 0; i < this.headerEditors.length; ++i) {
	  this.headerEditors[i].edit(_headers);
	}
	const _url = new URL(`${this.host}/api/v1/file/lookup`);
	const _init = {
	  method: 'POST',
	  headers: _headers,
	  body: JSON.stringify(lookupReq),
	} as RequestInit;
	
	const _req = new Request(_url.toString(), _init);
	try {
	  const resp = await fetch(_req);
	  if (resp.status !== 200) {
        const rj = await resp.json();
        return Promise.reject(rj);
      }
	  return resp.json();
	} catch (err) {
	  return Promise.reject(err);
	}
  }

   }
