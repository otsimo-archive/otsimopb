// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: models.proto

package otsimopb

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Gender int32

const (
	Gender_UNKNOWN Gender = 0
	Gender_MALE    Gender = 1
	Gender_FEMALE  Gender = 2
)

var Gender_name = map[int32]string{
	0: "UNKNOWN",
	1: "MALE",
	2: "FEMALE",
}

var Gender_value = map[string]int32{
	"UNKNOWN": 0,
	"MALE":    1,
	"FEMALE":  2,
}

func (x Gender) String() string {
	return proto.EnumName(Gender_name, int32(x))
}

func (Gender) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0}
}

type ReleaseState int32

const (
	ReleaseState_CREATED     ReleaseState = 0
	ReleaseState_DEVELOPMENT ReleaseState = 1
	ReleaseState_WAITING     ReleaseState = 2
	ReleaseState_REJECTED    ReleaseState = 3
	ReleaseState_VALIDATED   ReleaseState = 4
	ReleaseState_PRODUCTION  ReleaseState = 5
)

var ReleaseState_name = map[int32]string{
	0: "CREATED",
	1: "DEVELOPMENT",
	2: "WAITING",
	3: "REJECTED",
	4: "VALIDATED",
	5: "PRODUCTION",
}

var ReleaseState_value = map[string]int32{
	"CREATED":     0,
	"DEVELOPMENT": 1,
	"WAITING":     2,
	"REJECTED":    3,
	"VALIDATED":   4,
	"PRODUCTION":  5,
}

func (x ReleaseState) String() string {
	return proto.EnumName(ReleaseState_name, int32(x))
}

func (ReleaseState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{1}
}

type Address struct {
	StreetAddress        string   `protobuf:"bytes,1,opt,name=street_address,json=streetAddress,proto3" json:"street_address,omitempty" bson:"street_address,omitempty"`
	City                 string   `protobuf:"bytes,2,opt,name=city,proto3" json:"city,omitempty" bson:"city,omitempty"`
	State                string   `protobuf:"bytes,3,opt,name=state,proto3" json:"state,omitempty" bson:"state,omitempty"`
	ZipCode              string   `protobuf:"bytes,4,opt,name=zip_code,json=zipCode,proto3" json:"zip_code,omitempty" bson:"zip_code,omitempty"`
	CountryCode          string   `protobuf:"bytes,5,opt,name=country_code,json=countryCode,proto3" json:"country_code,omitempty" bson:"country_code,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Address) Reset()         { *m = Address{} }
func (m *Address) String() string { return proto.CompactTextString(m) }
func (*Address) ProtoMessage()    {}
func (*Address) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{0}
}
func (m *Address) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Address) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Address.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Address) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Address.Merge(m, src)
}
func (m *Address) XXX_Size() int {
	return m.Size()
}
func (m *Address) XXX_DiscardUnknown() {
	xxx_messageInfo_Address.DiscardUnknown(m)
}

var xxx_messageInfo_Address proto.InternalMessageInfo

type Profile struct {
	Id                   string            `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" bson:"_id,omitempty"`
	Email                string            `protobuf:"bytes,2,opt,name=email,proto3" json:"email,omitempty" bson:"email,omitempty"`
	FirstName            string            `protobuf:"bytes,3,opt,name=first_name,json=firstName,proto3" json:"first_name,omitempty" bson:"first_name,omitempty"`
	LastName             string            `protobuf:"bytes,4,opt,name=last_name,json=lastName,proto3" json:"last_name,omitempty" bson:"last_name,omitempty"`
	Language             string            `protobuf:"bytes,5,opt,name=language,proto3" json:"language,omitempty" bson:"language,omitempty"`
	MobilePhone          string            `protobuf:"bytes,6,opt,name=mobile_phone,json=mobilePhone,proto3" json:"mobile_phone,omitempty" bson:"mobile_phone,omitempty"`
	Address              *Address          `protobuf:"bytes,7,opt,name=address,proto3" json:"address,omitempty" bson:"address,omitempty"`
	CreatedAt            int64             `protobuf:"varint,8,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty" bson:"created_at,omitempty"`
	LastUpdated          int64             `protobuf:"varint,9,opt,name=last_updated,json=lastUpdated,proto3" json:"last_updated,omitempty" bson:"last_updated,omitempty"`
	Locale               string            `protobuf:"bytes,10,opt,name=locale,proto3" json:"locale,omitempty" bson:"locale,omitempty"`
	Timezone             int32             `protobuf:"varint,11,opt,name=timezone,proto3" json:"timezone,omitempty" bson:"timezone,omitempty"`
	Country              string            `protobuf:"bytes,12,opt,name=country,proto3" json:"country,omitempty" bson:"country,omitempty"`
	Labels               map[string]string `protobuf:"bytes,13,rep,name=labels,proto3" json:"labels,omitempty" bson:"labels" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Profile) Reset()         { *m = Profile{} }
func (m *Profile) String() string { return proto.CompactTextString(m) }
func (*Profile) ProtoMessage()    {}
func (*Profile) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{1}
}
func (m *Profile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Profile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Profile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Profile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Profile.Merge(m, src)
}
func (m *Profile) XXX_Size() int {
	return m.Size()
}
func (m *Profile) XXX_DiscardUnknown() {
	xxx_messageInfo_Profile.DiscardUnknown(m)
}

var xxx_messageInfo_Profile proto.InternalMessageInfo

type ChildGameEntry struct {
	Id                   string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" bson:"id"`
	Active               bool   `protobuf:"varint,2,opt,name=active,proto3" json:"active,omitempty" bson:"active"`
	DashboardIndex       int32  `protobuf:"varint,3,opt,name=dashboard_index,json=dashboardIndex,proto3" json:"dashboard_index,omitempty" bson:"dashboard_index"`
	Settings             []byte `protobuf:"bytes,4,opt,name=settings,proto3" json:"settings,omitempty" bson:"settings"`
	AddedAt              int64  `protobuf:"varint,5,opt,name=added_at,json=addedAt,proto3" json:"added_at,omitempty" bson:"added_at"`
	ActivationChangedAt  int64  `protobuf:"varint,6,opt,name=activation_changed_at,json=activationChangedAt,proto3" json:"activation_changed_at,omitempty" bson:"activation_changed_at"`
	UpdatedAt            int64  `protobuf:"varint,7,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty" bson:"updated_at"`
	LocalSettings        []byte `protobuf:"bytes,8,opt,name=local_settings,json=localSettings,proto3" json:"local_settings,omitempty" bson:"local_settings"`
	LocalSettingsVersion int64  `protobuf:"varint,9,opt,name=local_settings_version,json=localSettingsVersion,proto3" json:"local_settings_version,omitempty" bson:"local_settings_version"`
	// LimitAccess permits user to access to game only if on of the contitions
	// match
	LimitAccess          []string `protobuf:"bytes,10,rep,name=limit_access,json=limitAccess,proto3" json:"limit_access,omitempty" bson:"limit_access"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChildGameEntry) Reset()         { *m = ChildGameEntry{} }
func (m *ChildGameEntry) String() string { return proto.CompactTextString(m) }
func (*ChildGameEntry) ProtoMessage()    {}
func (*ChildGameEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{2}
}
func (m *ChildGameEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChildGameEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChildGameEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChildGameEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChildGameEntry.Merge(m, src)
}
func (m *ChildGameEntry) XXX_Size() int {
	return m.Size()
}
func (m *ChildGameEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_ChildGameEntry.DiscardUnknown(m)
}

var xxx_messageInfo_ChildGameEntry proto.InternalMessageInfo

type Child struct {
	Id                   string            `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" bson:"_id,omitempty"`
	ParentId             string            `protobuf:"bytes,2,opt,name=parent_id,json=parentId,proto3" json:"parent_id,omitempty" bson:"parent_id,omitempty"`
	FirstName            string            `protobuf:"bytes,3,opt,name=first_name,json=firstName,proto3" json:"first_name,omitempty" bson:"first_name,omitempty"`
	LastName             string            `protobuf:"bytes,4,opt,name=last_name,json=lastName,proto3" json:"last_name,omitempty" bson:"last_name,omitempty"`
	BirthDay             int64             `protobuf:"varint,5,opt,name=birth_day,json=birthDay,proto3" json:"birth_day,omitempty" bson:"birth_day,omitempty"`
	Gender               Gender            `protobuf:"varint,7,opt,name=gender,proto3,enum=apipb.Gender" json:"gender,omitempty" bson:"gender,omitempty"`
	Language             string            `protobuf:"bytes,8,opt,name=language,proto3" json:"language,omitempty" bson:"language,omitempty"`
	Games                []*ChildGameEntry `protobuf:"bytes,9,rep,name=games,proto3" json:"games,omitempty" bson:"games,omitempty"`
	Active               bool              `protobuf:"varint,10,opt,name=active,proto3" json:"active,omitempty" bson:"active,omitempty"`
	LoggedIn             bool              `protobuf:"varint,11,opt,name=logged_in,json=loggedIn,proto3" json:"logged_in,omitempty" bson:"logged_in,omitempty"`
	SoundsEnabled        bool              `protobuf:"varint,12,opt,name=sounds_enabled,json=soundsEnabled,proto3" json:"sounds_enabled,omitempty" bson:"sounds_enabled,omitempty"`
	Locale               string            `protobuf:"bytes,13,opt,name=locale,proto3" json:"locale,omitempty" bson:"locale,omitempty"`
	CreatedAt            int64             `protobuf:"varint,15,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty" bson:"created_at,omitempty"`
	LastUpdated          int64             `protobuf:"varint,16,opt,name=last_updated,json=lastUpdated,proto3" json:"last_updated,omitempty" bson:"last_updated,omitempty"`
	ChildInfo            map[string]string `protobuf:"bytes,17,rep,name=child_info,json=childInfo,proto3" json:"child_info,omitempty" bson:"child_info,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	TotalStarCount       int32             `protobuf:"varint,18,opt,name=total_star_count,json=totalStarCount,proto3" json:"total_star_count,omitempty" bson:"total_star_count,omitempty"`
	LevelStarCount       int32             `protobuf:"varint,19,opt,name=level_star_count,json=levelStarCount,proto3" json:"level_star_count,omitempty" bson:"level_star_count,omitempty"`
	Level                int32             `protobuf:"varint,20,opt,name=level,proto3" json:"level,omitempty" bson:"level,omitempty"`
	Badges               []*Badge          `protobuf:"bytes,21,rep,name=badges,proto3" json:"badges,omitempty" bson:"badges,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Child) Reset()         { *m = Child{} }
func (m *Child) String() string { return proto.CompactTextString(m) }
func (*Child) ProtoMessage()    {}
func (*Child) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{3}
}
func (m *Child) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Child) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Child.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Child) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Child.Merge(m, src)
}
func (m *Child) XXX_Size() int {
	return m.Size()
}
func (m *Child) XXX_DiscardUnknown() {
	xxx_messageInfo_Child.DiscardUnknown(m)
}

var xxx_messageInfo_Child proto.InternalMessageInfo

type Badge struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	CreatedAt            int64    `protobuf:"varint,2,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	Level                int32    `protobuf:"varint,3,opt,name=level,proto3" json:"level,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Badge) Reset()         { *m = Badge{} }
func (m *Badge) String() string { return proto.CompactTextString(m) }
func (*Badge) ProtoMessage()    {}
func (*Badge) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{4}
}
func (m *Badge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Badge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Badge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Badge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Badge.Merge(m, src)
}
func (m *Badge) XXX_Size() int {
	return m.Size()
}
func (m *Badge) XXX_DiscardUnknown() {
	xxx_messageInfo_Badge.DiscardUnknown(m)
}

var xxx_messageInfo_Badge proto.InternalMessageInfo

type Author struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty" bson:"name,omitempty"`
	Email                string   `protobuf:"bytes,2,opt,name=email,proto3" json:"email,omitempty" bson:"email,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Author) Reset()         { *m = Author{} }
func (m *Author) String() string { return proto.CompactTextString(m) }
func (*Author) ProtoMessage()    {}
func (*Author) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{5}
}
func (m *Author) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Author) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Author.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Author) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Author.Merge(m, src)
}
func (m *Author) XXX_Size() int {
	return m.Size()
}
func (m *Author) XXX_DiscardUnknown() {
	xxx_messageInfo_Author.DiscardUnknown(m)
}

var xxx_messageInfo_Author proto.InternalMessageInfo

type GameMetadata struct {
	Language string `protobuf:"bytes,1,opt,name=language,proto3" json:"language,omitempty" bson:"language,omitempty"`
	// Visible Name
	VisibleName string `protobuf:"bytes,2,opt,name=visible_name,json=visibleName,proto3" json:"visible_name,omitempty" bson:"visible_name,omitempty"`
	// Summary is summary of game
	Summary string `protobuf:"bytes,3,opt,name=summary,proto3" json:"summary,omitempty" bson:"summary,omitempty"`
	// Description
	Description string `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty" bson:"description,omitempty"`
	// Logo is a rectangle image
	Logo string `protobuf:"bytes,5,opt,name=logo,proto3" json:"logo,omitempty" bson:"logo,omitempty"`
	// Icon is a square image
	Icon string `protobuf:"bytes,6,opt,name=icon,proto3" json:"icon,omitempty" bson:"icon,omitempty"`
	// Keywords
	Keywords []string `protobuf:"bytes,7,rep,name=keywords,proto3" json:"keywords,omitempty" bson:"keywords,omitempty"`
	// Images are image files that show on market
	Images []string `protobuf:"bytes,8,rep,name=images,proto3" json:"images,omitempty" bson:"images,omitempty"`
	// InfoSlug is the id of the content which describes how to play this game
	InfoSlug string `protobuf:"bytes,9,opt,name=info_slug,json=infoSlug,proto3" json:"info_slug,omitempty" bson:"info_slug,omitempty"`
	// Assets are asset folders or paths for this language
	Assets []string `protobuf:"bytes,10,rep,name=assets,proto3" json:"assets,omitempty" bson:"assets,omitempty"`
	// Localized Annotations
	Annotations          map[string]string `protobuf:"bytes,11,rep,name=annotations,proto3" json:"annotations,omitempty" bson:"annotations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *GameMetadata) Reset()         { *m = GameMetadata{} }
func (m *GameMetadata) String() string { return proto.CompactTextString(m) }
func (*GameMetadata) ProtoMessage()    {}
func (*GameMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{6}
}
func (m *GameMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GameMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameMetadata.Merge(m, src)
}
func (m *GameMetadata) XXX_Size() int {
	return m.Size()
}
func (m *GameMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_GameMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_GameMetadata proto.InternalMessageInfo

type GameManifest struct {
	// Unique Name of game
	UniqueName string `protobuf:"bytes,1,opt,name=unique_name,json=uniqueName,proto3" json:"unique_name,omitempty" bson:"unique_name,omitempty" cli:"Unique Name"`
	// Licence
	Licence string `protobuf:"bytes,2,opt,name=licence,proto3" json:"licence,omitempty" bson:"licence,omitempty" cli:"Licence"`
	// Languages
	Languages []string `protobuf:"bytes,3,rep,name=languages,proto3" json:"languages,omitempty" bson:"languages,omitempty"`
	// Homepage is the website of game
	Homepage string `protobuf:"bytes,4,opt,name=homepage,proto3" json:"homepage,omitempty" bson:"homepage,omitempty"`
	// Main points to index.html file
	Main string `protobuf:"bytes,5,opt,name=main,proto3" json:"main,omitempty" bson:"main" cli:"Main"`
	// Version is current version for using on manifest file
	Version string `protobuf:"bytes,6,opt,name=version,proto3" json:"version,omitempty" bson:"version" cli:"Version"`
	// Authors is for using at manifest file
	Authors []*Author `protobuf:"bytes,7,rep,name=authors,proto3" json:"authors,omitempty" bson:"authors"`
	// Repository
	Repository string `protobuf:"bytes,8,opt,name=repository,proto3" json:"repository,omitempty" bson:"repository"`
	// SupportedOrientations are the orientations that can be used for this app
	SupportedOrientations []string `protobuf:"bytes,9,rep,name=supported_orientations,json=supportedOrientations,proto3" json:"supported_orientations,omitempty" bson:"supported_orientations,omitempty"`
	// Metadata information for each languages
	Metadata []*GameMetadata `protobuf:"bytes,13,rep,name=metadata,proto3" json:"metadata,omitempty" bson:"metadata,omitempty"`
	// Exclude directories when building
	Exclude []string `protobuf:"bytes,14,rep,name=exclude,proto3" json:"exclude,omitempty" bson:"exclude"`
	// Settings.json path
	Settings string `protobuf:"bytes,15,opt,name=settings,proto3" json:"settings,omitempty" bson:"settings,omitempty"`
	// KV directory path
	KvPath string `protobuf:"bytes,16,opt,name=kv_path,json=kvPath,proto3" json:"kv_path,omitempty" bson:"kv_path,omitempty"`
	// DeveloperName is the visible developer name
	DeveloperName string `protobuf:"bytes,17,opt,name=developer_name,json=developerName,proto3" json:"developer_name,omitempty" bson:"developer_name,omitempty"`
	// DefaultLanguage
	DefaultLanguage string `protobuf:"bytes,18,opt,name=default_language,json=defaultLanguage,proto3" json:"default_language,omitempty" bson:"default_language,omitempty"`
	// Loading Background Color of the Game
	LoadingColor string `protobuf:"bytes,19,opt,name=loading_color,json=loadingColor,proto3" json:"loading_color,omitempty" bson:"loading_color,omitempty"`
	// Capabilities are required host app features. The most basic capability is
	// 'sandbox'.
	Capabilities []string `protobuf:"bytes,20,rep,name=capabilities,proto3" json:"capabilities,omitempty" bson:"capabilities,omitempty"`
	// AbTest determines whether or not this version is for ab testing
	AbTest string `protobuf:"bytes,21,opt,name=ab_test,json=abTest,proto3" json:"ab_test,omitempty" bson:"ab_test"`
	// Labels are string key value pairs
	Labels map[string]string `protobuf:"bytes,22,rep,name=labels,proto3" json:"labels,omitempty" bson:"labels" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// ManifestVersion
	ManifestVersion      int32                  `protobuf:"varint,23,opt,name=manifest_version,json=manifestVersion,proto3" json:"manifest_version,omitempty"`
	Options              map[string]*GameOption `protobuf:"bytes,24,rep,name=options,proto3" json:"options,omitempty" bson:"options" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *GameManifest) Reset()         { *m = GameManifest{} }
func (m *GameManifest) String() string { return proto.CompactTextString(m) }
func (*GameManifest) ProtoMessage()    {}
func (*GameManifest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{7}
}
func (m *GameManifest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameManifest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameManifest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GameManifest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameManifest.Merge(m, src)
}
func (m *GameManifest) XXX_Size() int {
	return m.Size()
}
func (m *GameManifest) XXX_DiscardUnknown() {
	xxx_messageInfo_GameManifest.DiscardUnknown(m)
}

var xxx_messageInfo_GameManifest proto.InternalMessageInfo

type GameEnumGroup struct {
	Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	DefaultValue         string   `protobuf:"bytes,2,opt,name=default_value,json=defaultValue,proto3" json:"default_value,omitempty"`
	Values               []string `protobuf:"bytes,3,rep,name=values,proto3" json:"values,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GameEnumGroup) Reset()         { *m = GameEnumGroup{} }
func (m *GameEnumGroup) String() string { return proto.CompactTextString(m) }
func (*GameEnumGroup) ProtoMessage()    {}
func (*GameEnumGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{8}
}
func (m *GameEnumGroup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameEnumGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameEnumGroup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GameEnumGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameEnumGroup.Merge(m, src)
}
func (m *GameEnumGroup) XXX_Size() int {
	return m.Size()
}
func (m *GameEnumGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_GameEnumGroup.DiscardUnknown(m)
}

var xxx_messageInfo_GameEnumGroup proto.InternalMessageInfo

type GameOption struct {
	Id                   string           `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Type                 string           `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	Description          string           `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	Default              string           `protobuf:"bytes,4,opt,name=default,proto3" json:"default,omitempty"`
	Enum                 []string         `protobuf:"bytes,5,rep,name=enum,proto3" json:"enum,omitempty"`
	Format               string           `protobuf:"bytes,6,opt,name=format,proto3" json:"format,omitempty"`
	MinValue             float64          `protobuf:"fixed64,7,opt,name=min_value,json=minValue,proto3" json:"min_value,omitempty"`
	MaxValue             float64          `protobuf:"fixed64,8,opt,name=max_value,json=maxValue,proto3" json:"max_value,omitempty"`
	Image                string           `protobuf:"bytes,9,opt,name=image,proto3" json:"image,omitempty"`
	SortKey              string           `protobuf:"bytes,10,opt,name=sort_key,json=sortKey,proto3" json:"sort_key,omitempty"`
	EnumGroups           []*GameEnumGroup `protobuf:"bytes,11,rep,name=enum_groups,json=enumGroups,proto3" json:"enum_groups,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *GameOption) Reset()         { *m = GameOption{} }
func (m *GameOption) String() string { return proto.CompactTextString(m) }
func (*GameOption) ProtoMessage()    {}
func (*GameOption) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{9}
}
func (m *GameOption) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameOption) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameOption.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GameOption) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameOption.Merge(m, src)
}
func (m *GameOption) XXX_Size() int {
	return m.Size()
}
func (m *GameOption) XXX_DiscardUnknown() {
	xxx_messageInfo_GameOption.DiscardUnknown(m)
}

var xxx_messageInfo_GameOption proto.InternalMessageInfo

type Game struct {
	Id                   string            `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" bson:"_id,omitempty"`
	UniqueName           string            `protobuf:"bytes,2,opt,name=unique_name,json=uniqueName,proto3" json:"unique_name,omitempty" bson:"unique_name,omitempty"`
	OwnerId              string            `protobuf:"bytes,3,opt,name=owner_id,json=ownerId,proto3" json:"owner_id,omitempty" bson:"owner_id,omitempty"`
	ProductionVersion    string            `protobuf:"bytes,4,opt,name=production_version,json=productionVersion,proto3" json:"production_version,omitempty" bson:"production_version,omitempty"`
	IsOnProduction       bool              `protobuf:"varint,5,opt,name=is_on_production,json=isOnProduction,proto3" json:"is_on_production,omitempty" bson:"is_on_production,omitempty"`
	CreatedAt            int64             `protobuf:"varint,6,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty" bson:"created_at,omitempty"`
	LastUpdated          int64             `protobuf:"varint,7,opt,name=last_updated,json=lastUpdated,proto3" json:"last_updated,omitempty" bson:"last_updated,omitempty"`
	Labels               map[string]string `protobuf:"bytes,8,rep,name=labels,proto3" json:"labels,omitempty" bson:"labels" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Game) Reset()         { *m = Game{} }
func (m *Game) String() string { return proto.CompactTextString(m) }
func (*Game) ProtoMessage()    {}
func (*Game) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{10}
}
func (m *Game) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Game) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Game.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Game) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Game.Merge(m, src)
}
func (m *Game) XXX_Size() int {
	return m.Size()
}
func (m *Game) XXX_DiscardUnknown() {
	xxx_messageInfo_Game.DiscardUnknown(m)
}

var xxx_messageInfo_Game proto.InternalMessageInfo

type GameRelease struct {
	ReleaseId            string            `protobuf:"bytes,1,opt,name=release_id,json=releaseId,proto3" json:"release_id,omitempty" bson:"_id"`
	GameId               string            `protobuf:"bytes,2,opt,name=game_id,json=gameId,proto3" json:"game_id,omitempty" bson:"game_id"`
	Version              string            `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty" bson:"version"`
	GameManifest         *GameManifest     `protobuf:"bytes,4,opt,name=game_manifest,json=gameManifest,proto3" json:"game_manifest,omitempty" bson:"game_manifest,omitempty"`
	ReleasedAt           int64             `protobuf:"varint,5,opt,name=released_at,json=releasedAt,proto3" json:"released_at,omitempty" bson:"released_at"`
	ReleasedBy           string            `protobuf:"bytes,6,opt,name=released_by,json=releasedBy,proto3" json:"released_by,omitempty" bson:"released_by,omitempty"`
	ReleaseState         ReleaseState      `protobuf:"varint,7,opt,name=release_state,json=releaseState,proto3,enum=apipb.ReleaseState" json:"release_state,omitempty" bson:"release_state"`
	ValidatedBy          string            `protobuf:"bytes,8,opt,name=validated_by,json=validatedBy,proto3" json:"validated_by,omitempty" bson:"validated_by,omitempty"`
	ValidatedAt          int64             `protobuf:"varint,9,opt,name=validated_at,json=validatedAt,proto3" json:"validated_at,omitempty" bson:"validated_at"`
	IntVersion           int64             `protobuf:"varint,10,opt,name=int_version,json=intVersion,proto3" json:"int_version,omitempty" bson:"int_version"`
	Storage              string            `protobuf:"bytes,11,opt,name=storage,proto3" json:"storage,omitempty" bson:"-"`
	ArchiveFormat        string            `protobuf:"bytes,12,opt,name=archive_format,json=archiveFormat,proto3" json:"archive_format,omitempty" bson:"-"`
	PackageUrl           string            `protobuf:"bytes,13,opt,name=package_url,json=packageUrl,proto3" json:"package_url,omitempty" bson:"-"`
	Packages             map[string]string `protobuf:"bytes,14,rep,name=packages,proto3" json:"packages,omitempty" bson:"-" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *GameRelease) Reset()         { *m = GameRelease{} }
func (m *GameRelease) String() string { return proto.CompactTextString(m) }
func (*GameRelease) ProtoMessage()    {}
func (*GameRelease) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{11}
}
func (m *GameRelease) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GameRelease) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GameRelease.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GameRelease) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GameRelease.Merge(m, src)
}
func (m *GameRelease) XXX_Size() int {
	return m.Size()
}
func (m *GameRelease) XXX_DiscardUnknown() {
	xxx_messageInfo_GameRelease.DiscardUnknown(m)
}

var xxx_messageInfo_GameRelease proto.InternalMessageInfo

type UploadToken struct {
	Token                string   `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty" bson:"token,omitempty"`
	ExpiresAt            int64    `protobuf:"varint,2,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at,omitempty" bson:"expires_at,omitempty"`
	UserId               string   `protobuf:"bytes,3,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty" bson:"user_id,omitempty"`
	GameId               string   `protobuf:"bytes,4,opt,name=game_id,json=gameId,proto3" json:"game_id,omitempty" bson:"game_id,omitempty"`
	NewVersion           string   `protobuf:"bytes,5,opt,name=new_version,json=newVersion,proto3" json:"new_version,omitempty" bson:"new_version,omitempty"`
	UploadTo             string   `protobuf:"bytes,6,opt,name=upload_to,json=uploadTo,proto3" json:"upload_to,omitempty" bson:"upload_to,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UploadToken) Reset()         { *m = UploadToken{} }
func (m *UploadToken) String() string { return proto.CompactTextString(m) }
func (*UploadToken) ProtoMessage()    {}
func (*UploadToken) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b5431a010549573, []int{12}
}
func (m *UploadToken) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadToken) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadToken.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadToken) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadToken.Merge(m, src)
}
func (m *UploadToken) XXX_Size() int {
	return m.Size()
}
func (m *UploadToken) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadToken.DiscardUnknown(m)
}

var xxx_messageInfo_UploadToken proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("apipb.Gender", Gender_name, Gender_value)
	proto.RegisterEnum("apipb.ReleaseState", ReleaseState_name, ReleaseState_value)
	proto.RegisterType((*Address)(nil), "apipb.Address")
	proto.RegisterType((*Profile)(nil), "apipb.Profile")
	proto.RegisterMapType((map[string]string)(nil), "apipb.Profile.LabelsEntry")
	proto.RegisterType((*ChildGameEntry)(nil), "apipb.ChildGameEntry")
	proto.RegisterType((*Child)(nil), "apipb.Child")
	proto.RegisterMapType((map[string]string)(nil), "apipb.Child.ChildInfoEntry")
	proto.RegisterType((*Badge)(nil), "apipb.Badge")
	proto.RegisterType((*Author)(nil), "apipb.Author")
	proto.RegisterType((*GameMetadata)(nil), "apipb.GameMetadata")
	proto.RegisterMapType((map[string]string)(nil), "apipb.GameMetadata.AnnotationsEntry")
	proto.RegisterType((*GameManifest)(nil), "apipb.GameManifest")
	proto.RegisterMapType((map[string]string)(nil), "apipb.GameManifest.LabelsEntry")
	proto.RegisterMapType((map[string]*GameOption)(nil), "apipb.GameManifest.OptionsEntry")
	proto.RegisterType((*GameEnumGroup)(nil), "apipb.GameEnumGroup")
	proto.RegisterType((*GameOption)(nil), "apipb.GameOption")
	proto.RegisterType((*Game)(nil), "apipb.Game")
	proto.RegisterMapType((map[string]string)(nil), "apipb.Game.LabelsEntry")
	proto.RegisterType((*GameRelease)(nil), "apipb.GameRelease")
	proto.RegisterMapType((map[string]string)(nil), "apipb.GameRelease.PackagesEntry")
	proto.RegisterType((*UploadToken)(nil), "apipb.UploadToken")
}

func init() { proto.RegisterFile("models.proto", fileDescriptor_0b5431a010549573) }

var fileDescriptor_0b5431a010549573 = []byte{
	// 2834 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x59, 0x4f, 0x6f, 0x1c, 0xc7,
	0xb1, 0xd7, 0x92, 0xdc, 0x7f, 0xb5, 0xbb, 0x24, 0xd5, 0x22, 0xa5, 0x35, 0x65, 0x71, 0xe8, 0xf1,
	0x7b, 0x36, 0xfd, 0x47, 0xb4, 0x21, 0x3f, 0xff, 0x93, 0x0c, 0xe3, 0xed, 0x92, 0xb4, 0x40, 0x59,
	0x22, 0x89, 0x11, 0x45, 0x3f, 0xbc, 0x04, 0x19, 0xf4, 0xee, 0x34, 0x97, 0x0d, 0xcd, 0xce, 0x4c,
	0x66, 0x66, 0x29, 0xad, 0x8f, 0xf9, 0x0e, 0x01, 0x02, 0xe4, 0x96, 0x0f, 0x91, 0x43, 0x3e, 0x81,
	0x8f, 0xb9, 0x1b, 0x58, 0x24, 0xf6, 0x39, 0x97, 0x05, 0x72, 0x0f, 0xba, 0xba, 0x7b, 0xb6, 0x7b,
	0xc5, 0x83, 0x69, 0x03, 0xc9, 0x85, 0x98, 0xad, 0x5f, 0x55, 0x4d, 0x4f, 0x75, 0xd5, 0xaf, 0xaa,
	0x9b, 0xd0, 0x1c, 0xc6, 0x01, 0x0b, 0xb3, 0x9d, 0x24, 0x8d, 0xf3, 0x98, 0x94, 0x69, 0xc2, 0x93,
	0xde, 0xc6, 0xda, 0x20, 0x1e, 0xc4, 0x28, 0xf9, 0x40, 0x3c, 0x49, 0xd0, 0xfd, 0xf3, 0x02, 0x54,
	0x3b, 0x41, 0x90, 0xb2, 0x2c, 0x23, 0x8f, 0x60, 0x39, 0xcb, 0x53, 0xc6, 0x72, 0x9f, 0x4a, 0x49,
	0xbb, 0xb4, 0x55, 0xda, 0xae, 0x77, 0xdf, 0x9c, 0x4e, 0x1c, 0xa7, 0x97, 0xc5, 0xd1, 0x7d, 0xd7,
	0xc6, 0xdf, 0x8f, 0x87, 0x3c, 0x67, 0xc3, 0x24, 0x1f, 0xbb, 0x5e, 0x4b, 0x42, 0xda, 0xd7, 0x5d,
	0x58, 0xea, 0xf3, 0x7c, 0xdc, 0x5e, 0x40, 0x0f, 0xaf, 0x4d, 0x27, 0xce, 0xba, 0xf4, 0x20, 0xa4,
	0xa6, 0x1d, 0xaa, 0x91, 0x0f, 0xa1, 0x9c, 0xe5, 0x34, 0x67, 0xed, 0x45, 0xd4, 0xdf, 0x98, 0x4e,
	0x9c, 0x9b, 0xfa, 0x8d, 0x34, 0x67, 0xa6, 0x81, 0x54, 0x24, 0x9f, 0x41, 0xed, 0x5b, 0x9e, 0xf8,
	0xfd, 0x38, 0x60, 0xed, 0x25, 0x34, 0xba, 0x33, 0x9d, 0x38, 0xaf, 0x49, 0x23, 0x8d, 0x98, 0x76,
	0xd5, 0x6f, 0x79, 0xb2, 0x1b, 0x07, 0x8c, 0xec, 0x41, 0xb3, 0x1f, 0x8f, 0xa2, 0x3c, 0x1d, 0x4b,
	0xeb, 0x32, 0x5a, 0xbf, 0x31, 0x9d, 0x38, 0x77, 0xd4, 0x12, 0x0d, 0xd4, 0xf4, 0xd0, 0x50, 0x80,
	0xf0, 0xe2, 0x7e, 0x5f, 0x81, 0xea, 0x71, 0x1a, 0x9f, 0xf1, 0x90, 0x91, 0x6d, 0x58, 0xe0, 0x81,
	0x0a, 0x56, 0x7b, 0x3a, 0x71, 0xd6, 0xa4, 0x1f, 0x9f, 0x07, 0xa6, 0xf9, 0x02, 0x0f, 0xc4, 0x77,
	0xb2, 0x21, 0xe5, 0xa1, 0x8a, 0x8b, 0xf1, 0x9d, 0x28, 0xb6, 0xbe, 0x13, 0x25, 0xe4, 0x4b, 0x80,
	0x33, 0x9e, 0x66, 0xb9, 0x1f, 0xd1, 0xa1, 0x0e, 0x8f, 0x33, 0x9d, 0x38, 0xb7, 0xa5, 0xd9, 0x0c,
	0x33, 0x6d, 0xeb, 0x28, 0x3e, 0xa4, 0x43, 0x46, 0x1e, 0x40, 0x3d, 0xa4, 0xda, 0x5c, 0x06, 0x6a,
	0x73, 0x3a, 0x71, 0x36, 0xa4, 0x79, 0x01, 0x99, 0xd6, 0x35, 0x21, 0x45, 0xe3, 0xcf, 0xa1, 0x16,
	0xd2, 0x68, 0x30, 0xa2, 0x03, 0x1d, 0x26, 0x23, 0xc8, 0x1a, 0x99, 0x33, 0x95, 0x42, 0x11, 0xe5,
	0x61, 0xdc, 0xe3, 0x21, 0xf3, 0x93, 0xf3, 0x38, 0x62, 0xed, 0xca, 0x7c, 0x94, 0x4d, 0xd4, 0x8a,
	0xb2, 0x04, 0x8e, 0x85, 0x9c, 0x7c, 0x05, 0x55, 0x9d, 0x8b, 0xd5, 0xad, 0xd2, 0x76, 0xe3, 0xde,
	0xf2, 0x0e, 0x66, 0xf3, 0x8e, 0xca, 0xb3, 0xee, 0xeb, 0xd3, 0x89, 0xd3, 0x96, 0x0e, 0x2f, 0x49,
	0x4a, 0x6d, 0x2c, 0xa2, 0xd8, 0x4f, 0x19, 0xcd, 0x59, 0xe0, 0xd3, 0xbc, 0x5d, 0xdb, 0x2a, 0x6d,
	0x2f, 0x9a, 0x51, 0x9c, 0x61, 0x56, 0x14, 0x95, 0xb8, 0x93, 0x8b, 0xaf, 0xc1, 0x50, 0x8d, 0x92,
	0x40, 0x48, 0xda, 0x75, 0xf4, 0x60, 0x7c, 0x8d, 0x89, 0x5a, 0x5f, 0x23, 0x80, 0x67, 0x52, 0x4e,
	0x3e, 0x82, 0x4a, 0x18, 0xf7, 0x69, 0xc8, 0xda, 0x80, 0xd1, 0xb8, 0x3d, 0x9d, 0x38, 0xb7, 0x94,
	0x3d, 0xca, 0x4d, 0x4b, 0xa5, 0x2a, 0xf6, 0x20, 0xe7, 0x43, 0xf6, 0xad, 0x08, 0x62, 0x63, 0xab,
	0xb4, 0x5d, 0x36, 0xf7, 0x40, 0x23, 0xd6, 0x1e, 0x68, 0x21, 0xf9, 0x04, 0xaa, 0x2a, 0x65, 0xdb,
	0x4d, 0x7c, 0xa1, 0x11, 0x2d, 0x05, 0x58, 0xd1, 0x52, 0x32, 0xb2, 0x0f, 0x95, 0x90, 0xf6, 0x58,
	0x98, 0xb5, 0x5b, 0x5b, 0x8b, 0xdb, 0x8d, 0x7b, 0x1b, 0x2a, 0xe8, 0x2a, 0xdf, 0x77, 0x1e, 0x23,
	0xb8, 0x2f, 0x74, 0xbb, 0xd7, 0xa7, 0x13, 0xa7, 0xa5, 0x63, 0x20, 0xc4, 0x62, 0xe5, 0xf8, 0xb0,
	0xf1, 0x39, 0x34, 0x0c, 0x4d, 0xb2, 0x0a, 0x8b, 0xcf, 0xd9, 0x58, 0x96, 0x89, 0x27, 0x1e, 0xc9,
	0x1a, 0x94, 0x2f, 0x68, 0x38, 0x62, 0xb2, 0x1a, 0x3c, 0xf9, 0xe3, 0xfe, 0xc2, 0x67, 0x25, 0xf7,
	0xc7, 0x25, 0x58, 0xde, 0x3d, 0xe7, 0x61, 0xf0, 0x90, 0x0e, 0x99, 0x34, 0xbf, 0x63, 0x14, 0x59,
	0x6b, 0x3a, 0x71, 0xea, 0xf2, 0xa5, 0x3c, 0x90, 0x95, 0xf5, 0x0e, 0x54, 0x68, 0x3f, 0xe7, 0x17,
	0xd2, 0x59, 0xcd, 0x5c, 0x97, 0x94, 0xbb, 0x9e, 0x52, 0x20, 0xbb, 0xb0, 0x12, 0xd0, 0xec, 0xbc,
	0x17, 0xd3, 0x34, 0xf0, 0x79, 0x14, 0xb0, 0x97, 0x58, 0x57, 0x65, 0xb3, 0x1c, 0xe7, 0x14, 0x5c,
	0x6f, 0xb9, 0x90, 0x1c, 0x08, 0x01, 0xf9, 0x00, 0x6a, 0x19, 0xcb, 0x73, 0x1e, 0x0d, 0x32, 0x2c,
	0xab, 0x66, 0xf7, 0xc6, 0x74, 0xe2, 0xac, 0x28, 0xd2, 0x52, 0x88, 0xeb, 0x15, 0x4a, 0x64, 0x07,
	0x6a, 0x34, 0x08, 0x64, 0x02, 0x96, 0x31, 0x7d, 0x0c, 0x03, 0x8d, 0xc8, 0x94, 0xc5, 0x94, 0x3b,
	0x81, 0x75, 0x5c, 0x2f, 0xcd, 0x79, 0x1c, 0xf9, 0xfd, 0x73, 0x1a, 0x0d, 0xa4, 0x71, 0x05, 0x8d,
	0xb7, 0xa6, 0x13, 0xe7, 0x75, 0xe3, 0xfb, 0xe6, 0xd5, 0x5c, 0xef, 0xc6, 0x4c, 0xbe, 0x2b, 0xc5,
	0x9d, 0x9c, 0xfc, 0x0f, 0x80, 0xca, 0x52, 0xe1, 0xaa, 0x8a, 0xae, 0xd6, 0xa7, 0x13, 0xe7, 0xba,
	0x74, 0x35, 0xc3, 0x5c, 0xaf, 0xae, 0x7e, 0x74, 0x72, 0xf2, 0xbf, 0xb0, 0x8c, 0xd9, 0xe8, 0x17,
	0x9f, 0x5c, 0xc3, 0x4f, 0x36, 0x78, 0xdd, 0xc6, 0x5d, 0xaf, 0x85, 0x82, 0xa7, 0xfa, 0xeb, 0xbf,
	0x81, 0x9b, 0xb6, 0x86, 0x7f, 0xc1, 0xd2, 0x8c, 0xc7, 0xd1, 0x25, 0xa5, 0x74, 0xa9, 0x9e, 0xeb,
	0xad, 0x59, 0x1e, 0x4f, 0xa5, 0x98, 0xdc, 0x87, 0x66, 0xc8, 0x87, 0x3c, 0xf7, 0x69, 0xbf, 0x2f,
	0x68, 0x02, 0xb6, 0x16, 0xb7, 0xeb, 0xdd, 0x5b, 0xd3, 0x89, 0x73, 0x43, 0xb9, 0x33, 0x50, 0x51,
	0x8f, 0xe2, 0x67, 0x47, 0xfe, 0xfa, 0x23, 0x40, 0x19, 0xb3, 0xec, 0x0a, 0x0c, 0xfe, 0x00, 0xea,
	0x09, 0x4d, 0x59, 0x94, 0xfb, 0x3c, 0x50, 0x2c, 0x6e, 0xf0, 0x69, 0x01, 0x59, 0x05, 0x29, 0xa5,
	0x07, 0xc1, 0x7f, 0x96, 0xcc, 0x1f, 0x40, 0xbd, 0xc7, 0xd3, 0xfc, 0xdc, 0x0f, 0xe8, 0x58, 0x65,
	0xa0, 0x61, 0x5c, 0x40, 0x96, 0x31, 0x4a, 0xf7, 0xe8, 0x98, 0x74, 0xa1, 0x32, 0x60, 0x51, 0xc0,
	0x52, 0xcc, 0x99, 0xe5, 0x7b, 0x2d, 0x45, 0x09, 0x0f, 0x51, 0x68, 0x32, 0x99, 0x54, 0xb3, 0x98,
	0x4c, 0x8a, 0xac, 0x6e, 0x52, 0xbb, 0x5a, 0x37, 0x79, 0x08, 0xe5, 0x01, 0x1d, 0xb2, 0xac, 0x5d,
	0x47, 0x42, 0x5a, 0x57, 0x6f, 0xb7, 0x29, 0xc2, 0xac, 0x5f, 0xd4, 0xb6, 0xda, 0x29, 0x4a, 0x04,
	0x05, 0x2b, 0x9a, 0x00, 0xa4, 0x09, 0x63, 0xe1, 0x52, 0x6e, 0x2d, 0x5c, 0x11, 0x86, 0x08, 0x7b,
	0x3c, 0x10, 0x75, 0xc5, 0x23, 0xe4, 0xe0, 0x9a, 0x15, 0x76, 0x0d, 0xd9, 0x4b, 0x47, 0xe9, 0x41,
	0x84, 0x53, 0x55, 0x3c, 0x8a, 0x82, 0xcc, 0x67, 0x11, 0xed, 0x85, 0x2c, 0x40, 0x2e, 0xae, 0x59,
	0x53, 0x95, 0x85, 0xdb, 0x53, 0x15, 0x42, 0xfb, 0x12, 0x31, 0x1a, 0x48, 0xeb, 0xa7, 0x37, 0x10,
	0xbb, 0xf7, 0xad, 0xfc, 0xe2, 0xde, 0xb7, 0xfa, 0xb3, 0x7a, 0xdf, 0xaf, 0x00, 0xfa, 0x62, 0xb7,
	0x7c, 0x1e, 0x9d, 0xc5, 0xed, 0xeb, 0xb8, 0x8d, 0xb7, 0xcd, 0x6d, 0x94, 0x7f, 0x0f, 0xa2, 0xb3,
	0x58, 0x6e, 0xa6, 0xb9, 0xc4, 0xc2, 0xd0, 0x5e, 0xa2, 0x36, 0x20, 0x47, 0xb0, 0x9a, 0xc7, 0xb9,
	0x60, 0x8d, 0x9c, 0xa6, 0x3e, 0xb6, 0xb1, 0x36, 0x41, 0x4a, 0xff, 0xef, 0xe9, 0xc4, 0x79, 0x43,
	0xf5, 0xca, 0x39, 0x0d, 0xd3, 0xd7, 0x32, 0x82, 0x4f, 0x73, 0x9a, 0xee, 0x0a, 0x48, 0x38, 0x0c,
	0xd9, 0x05, 0xb3, 0x1c, 0xde, 0x98, 0x77, 0x38, 0xaf, 0x61, 0x39, 0x44, 0x70, 0xe6, 0xf0, 0x43,
	0x28, 0xa3, 0xa4, 0xbd, 0x36, 0xdf, 0x69, 0x50, 0x6c, 0x65, 0x2a, 0x4a, 0x48, 0x07, 0x2a, 0x3d,
	0x1a, 0x0c, 0x58, 0xd6, 0x5e, 0xc7, 0x60, 0x35, 0x55, 0xb0, 0xba, 0x42, 0x68, 0xee, 0xbc, 0xd4,
	0xb2, 0x76, 0x5e, 0x8a, 0x36, 0xbe, 0x50, 0x4d, 0xb4, 0x08, 0xea, 0x95, 0x7a, 0xf0, 0x31, 0x94,
	0xf1, 0x5d, 0x84, 0xc0, 0x12, 0x12, 0x8e, 0xb4, 0xc2, 0x67, 0x72, 0xc7, 0x4a, 0x2a, 0x61, 0xbb,
	0x68, 0xe6, 0xcc, 0x9a, 0xfe, 0x5c, 0x6c, 0xac, 0xea, 0x93, 0x5c, 0x0e, 0x95, 0xce, 0x28, 0x3f,
	0x8f, 0x53, 0x71, 0x3c, 0x98, 0xb9, 0x34, 0xdb, 0xc8, 0x3c, 0x7d, 0xc9, 0xb7, 0x5d, 0x79, 0x6c,
	0x76, 0xff, 0x59, 0x86, 0xa6, 0x20, 0x86, 0x27, 0x2c, 0xa7, 0x01, 0xcd, 0xa9, 0x45, 0x3e, 0xa5,
	0x2b, 0x8f, 0xb2, 0x17, 0x3c, 0xe3, 0xbd, 0x90, 0x49, 0xe2, 0x5d, 0x98, 0x1f, 0x65, 0x4d, 0xd4,
	0x2a, 0x00, 0x05, 0x20, 0xfd, 0x7e, 0x02, 0xd5, 0x6c, 0x34, 0x1c, 0xd2, 0x74, 0xac, 0x88, 0xdf,
	0x18, 0xc6, 0x14, 0x60, 0x0d, 0x63, 0x4a, 0x46, 0xba, 0xd0, 0x08, 0x58, 0xd6, 0x4f, 0x79, 0x22,
	0x3a, 0xb9, 0x62, 0x7d, 0xa3, 0xfb, 0x1b, 0xa0, 0xf5, 0x6e, 0x43, 0x2e, 0xc2, 0x1d, 0xc6, 0x83,
	0x58, 0xcd, 0xf0, 0x56, 0xd7, 0x1e, 0x58, 0x35, 0x85, 0x6a, 0x42, 0x9d, 0xf7, 0xe3, 0x48, 0xcd,
	0xec, 0x86, 0xba, 0x90, 0x5a, 0xea, 0x42, 0x20, 0x42, 0xfb, 0x9c, 0x8d, 0x5f, 0xc4, 0x69, 0x20,
	0xa6, 0xf4, 0x45, 0x3b, 0xb4, 0x1a, 0xb1, 0x42, 0xab, 0x85, 0x82, 0xd0, 0xf8, 0x90, 0x8a, 0x24,
	0xaf, 0xa1, 0xa1, 0x91, 0xd6, 0x52, 0x6e, 0xa5, 0xb5, 0x14, 0x09, 0x3a, 0x16, 0x5c, 0xe0, 0x67,
	0xe1, 0x68, 0x80, 0xe3, 0x83, 0xd5, 0x05, 0x0b, 0xc8, 0x7a, 0xa3, 0x90, 0x3e, 0x0d, 0x47, 0x03,
	0x6c, 0x00, 0x59, 0xc6, 0x72, 0x3d, 0x29, 0x98, 0x0d, 0x00, 0xe5, 0x76, 0x03, 0x40, 0x11, 0x39,
	0x87, 0x06, 0x8d, 0xa2, 0x38, 0xc7, 0x61, 0x2a, 0x6b, 0x37, 0xb0, 0x20, 0xff, 0x4b, 0xb7, 0x40,
	0x23, 0xcd, 0x76, 0x3a, 0x33, 0x35, 0x49, 0x63, 0xe6, 0x9c, 0x36, 0xc3, 0xac, 0x9d, 0x32, 0xe4,
	0x1b, 0x5f, 0xc2, 0xea, 0xbc, 0x8b, 0x2b, 0x15, 0xed, 0xef, 0x9a, 0x2a, 0xef, 0x69, 0xc4, 0xcf,
	0x58, 0x96, 0x93, 0xa7, 0xd0, 0x18, 0x45, 0xfc, 0xb7, 0x23, 0x95, 0xbb, 0x32, 0xf5, 0xef, 0x4d,
	0x27, 0xce, 0x8e, 0x9a, 0xf8, 0x66, 0xa0, 0xb1, 0xa8, 0xad, 0x7e, 0xc8, 0xef, 0xbb, 0xcf, 0x10,
	0xdb, 0x12, 0xe9, 0xeb, 0x7a, 0x20, 0x35, 0x31, 0x97, 0xf7, 0xa0, 0x1a, 0xf2, 0x3e, 0x8b, 0xfa,
	0xba, 0x18, 0xde, 0x9d, 0x4e, 0x9c, 0xb7, 0xf4, 0xbc, 0x85, 0xc0, 0x2b, 0xce, 0x1e, 0x4b, 0xb9,
	0xeb, 0x69, 0x53, 0xf2, 0x85, 0x98, 0x66, 0x64, 0x8d, 0x65, 0xed, 0x45, 0xdc, 0x0d, 0x6b, 0x9a,
	0x51, 0x90, 0xc5, 0xf9, 0x85, 0x54, 0x64, 0xdd, 0x79, 0x3c, 0x64, 0x89, 0x28, 0xe8, 0x57, 0x2e,
	0x00, 0x34, 0x62, 0xe5, 0x80, 0x16, 0x92, 0x1d, 0x58, 0x1a, 0x52, 0x1e, 0xa9, 0x72, 0x30, 0xd8,
	0x44, 0x48, 0xd5, 0x72, 0x9f, 0x88, 0x47, 0x0f, 0xf5, 0xc8, 0x7d, 0xa8, 0xea, 0x69, 0xb5, 0x32,
	0x5f, 0x7e, 0x7a, 0x3c, 0x95, 0x56, 0xa7, 0x7a, 0x58, 0xd5, 0x06, 0xe4, 0x01, 0x54, 0x29, 0x72,
	0x9e, 0xac, 0x8d, 0x46, 0x31, 0x39, 0x49, 0x26, 0xec, 0x92, 0xe9, 0xc4, 0x59, 0x56, 0xf9, 0x21,
	0xf5, 0xc4, 0x19, 0x40, 0x3e, 0x91, 0x8f, 0x01, 0x52, 0x96, 0xc4, 0x19, 0xcf, 0xe3, 0x74, 0xac,
	0x66, 0x26, 0x63, 0x5a, 0x9f, 0x61, 0xae, 0x67, 0x28, 0x92, 0x1e, 0xdc, 0xcc, 0x46, 0x49, 0x12,
	0xa7, 0x82, 0x9e, 0xe3, 0x94, 0xb3, 0x48, 0x67, 0x6e, 0x1d, 0xa3, 0xfc, 0xde, 0x74, 0xe2, 0xbc,
	0xad, 0x99, 0xe7, 0x32, 0x3d, 0x33, 0x6c, 0xeb, 0x85, 0xca, 0x91, 0xa1, 0x41, 0x0e, 0xa1, 0x36,
	0x54, 0x49, 0xaf, 0x4e, 0x89, 0x37, 0x2e, 0xa9, 0x07, 0x73, 0x4f, 0xb4, 0xba, 0xb5, 0x27, 0x5a,
	0x48, 0xde, 0x87, 0x2a, 0x7b, 0xd9, 0x0f, 0x47, 0x01, 0x6b, 0x2f, 0xe3, 0x22, 0x8d, 0xc0, 0x28,
	0xc0, 0xf5, 0xb4, 0x8a, 0xd8, 0xfc, 0xe2, 0x28, 0xb2, 0x32, 0xbf, 0xf9, 0x1a, 0xb1, 0x5e, 0x54,
	0x9c, 0xc3, 0x3e, 0x86, 0xea, 0xf3, 0x0b, 0x3f, 0xa1, 0xf9, 0x39, 0x4e, 0x32, 0x16, 0x0f, 0x2b,
	0xc0, 0xa2, 0x80, 0xe7, 0x17, 0xc7, 0x34, 0x3f, 0x17, 0x63, 0x5c, 0x20, 0x9a, 0x58, 0x9c, 0xb0,
	0x54, 0x96, 0xd2, 0xf5, 0xf9, 0xcb, 0x31, 0x1b, 0xb7, 0xc6, 0xb8, 0x02, 0xc2, 0xf2, 0x39, 0x86,
	0xd5, 0x80, 0x9d, 0xd1, 0x51, 0x98, 0xfb, 0x45, 0x4f, 0x22, 0xe8, 0xcd, 0x98, 0x2e, 0xe6, 0x35,
	0x4c, 0x7f, 0x2b, 0x0a, 0x7c, 0x3c, 0x9b, 0x8f, 0x5b, 0x61, 0x4c, 0x03, 0x1e, 0x0d, 0xfc, 0x7e,
	0x1c, 0xc6, 0x29, 0x0e, 0x2b, 0xf5, 0xae, 0x3b, 0x9d, 0x38, 0x9b, 0x9a, 0xe9, 0x0d, 0xd8, 0xf4,
	0xd5, 0x54, 0xc8, 0xae, 0x00, 0xc8, 0x3e, 0x34, 0xfb, 0x34, 0xa1, 0x3d, 0x1e, 0xf2, 0x9c, 0xb3,
	0xac, 0xbd, 0x86, 0x7b, 0x61, 0x5e, 0x8e, 0x19, 0xa8, 0xe5, 0xc6, 0x04, 0xc8, 0x7b, 0x50, 0xa5,
	0x3d, 0x3f, 0x67, 0x59, 0xde, 0x5e, 0xc7, 0x95, 0x98, 0x69, 0x2e, 0x01, 0xc1, 0xae, 0xbd, 0x13,
	0x41, 0x51, 0x8f, 0x8a, 0xeb, 0x86, 0x9b, 0x98, 0x48, 0x8e, 0x99, 0x48, 0x8a, 0xc7, 0x7e, 0xe2,
	0x9d, 0x03, 0x79, 0x07, 0x56, 0x87, 0xca, 0xa4, 0x38, 0x61, 0xde, 0xc2, 0x19, 0x64, 0x45, 0xcb,
	0xf5, 0xc9, 0xf1, 0x10, 0xaa, 0x71, 0x22, 0xcb, 0xa2, 0x8d, 0xef, 0xdd, 0xba, 0xec, 0xbd, 0x47,
	0x89, 0x41, 0xe6, 0xc6, 0x57, 0x28, 0x53, 0xd7, 0xd3, 0x4e, 0x7e, 0xc1, 0x75, 0xc7, 0xc6, 0x13,
	0x68, 0x9a, 0xef, 0xb9, 0xc4, 0xf6, 0x6d, 0xd3, 0xb6, 0x71, 0xef, 0xba, 0xb1, 0x54, 0x69, 0x69,
	0x36, 0x81, 0xdf, 0x40, 0x4b, 0x1e, 0x8a, 0x46, 0xc3, 0x87, 0x69, 0x3c, 0x4a, 0x2e, 0xf1, 0xf7,
	0x26, 0xb4, 0x74, 0x82, 0x99, 0x6b, 0x6a, 0x2a, 0xe1, 0xa9, 0x90, 0x91, 0x9b, 0x50, 0x41, 0x50,
	0xb1, 0xb3, 0xa7, 0x7e, 0xb9, 0x7f, 0x59, 0x00, 0x98, 0xbd, 0x99, 0x2c, 0xcf, 0x0e, 0xcf, 0x78,
	0x44, 0x26, 0xb0, 0x94, 0x8f, 0x13, 0xed, 0x12, 0x9f, 0xc9, 0x96, 0x3d, 0xc5, 0xe0, 0x04, 0x64,
	0xcf, 0x28, 0x6d, 0xa8, 0xaa, 0x97, 0x4b, 0x3a, 0xf7, 0xf4, 0x4f, 0xe1, 0x8f, 0x45, 0xa3, 0x61,
	0xbb, 0x8c, 0x8b, 0xc0, 0x67, 0xb1, 0xb4, 0xb3, 0x38, 0x1d, 0xaa, 0xeb, 0x90, 0xba, 0xa7, 0x7e,
	0x91, 0xdb, 0x50, 0x1f, 0xf2, 0x48, 0x7d, 0x93, 0x38, 0xaa, 0x96, 0xbc, 0xda, 0x90, 0x47, 0xf2,
	0x7b, 0x04, 0x48, 0x5f, 0x2a, 0xb0, 0xa6, 0x40, 0xfa, 0x52, 0x82, 0x6b, 0x50, 0xc6, 0xf9, 0x42,
	0x4e, 0x14, 0x9e, 0xfc, 0x41, 0x5e, 0x83, 0x5a, 0x16, 0xa7, 0xb9, 0x2f, 0xc2, 0x07, 0x72, 0x59,
	0xe2, 0xf7, 0xd7, 0x6c, 0x4c, 0x3e, 0x86, 0x86, 0x58, 0x8a, 0x3f, 0x10, 0x21, 0xd6, 0x43, 0xc1,
	0x9a, 0xb1, 0x31, 0x45, 0xfc, 0x3d, 0x60, 0xfa, 0x31, 0x73, 0xbf, 0x5f, 0x82, 0x25, 0x81, 0x5e,
	0xe1, 0xce, 0xa1, 0x63, 0xf7, 0xf0, 0x85, 0xf9, 0x1e, 0x74, 0x79, 0x0f, 0xb7, 0x3a, 0xf6, 0x67,
	0x50, 0x8b, 0x5f, 0x44, 0x2c, 0xf5, 0x79, 0xa0, 0xc6, 0x4f, 0x83, 0x30, 0x35, 0x62, 0xcd, 0x9f,
	0x28, 0x3c, 0x08, 0xc8, 0x29, 0x90, 0x24, 0x8d, 0x83, 0x51, 0x1f, 0x2f, 0x98, 0x74, 0x4d, 0xc9,
	0x8e, 0xfb, 0xf6, 0x74, 0xe2, 0xbc, 0xa9, 0x6e, 0x3e, 0x5e, 0xd1, 0x31, 0xbd, 0x5d, 0x9f, 0xc1,
	0xba, 0xfc, 0x8e, 0x60, 0x95, 0x67, 0x7e, 0x1c, 0xf9, 0x33, 0x08, 0x1b, 0x72, 0xcd, 0x24, 0xc1,
	0x79, 0x0d, 0xeb, 0x88, 0xc5, 0xb3, 0xa3, 0xe8, 0xb8, 0x80, 0xe6, 0xce, 0xb9, 0x95, 0x5f, 0x7c,
	0xce, 0xad, 0xfe, 0xac, 0x73, 0x6e, 0xb7, 0x20, 0xb3, 0x1a, 0x26, 0xc4, 0x2d, 0x23, 0x21, 0xfe,
	0x0d, 0x17, 0xa7, 0xbf, 0xaf, 0x42, 0x43, 0xbc, 0xca, 0x63, 0x21, 0xa3, 0x19, 0x23, 0x77, 0xc5,
	0x04, 0x81, 0x8f, 0x7e, 0x91, 0x6c, 0xcb, 0xd3, 0x89, 0x03, 0x45, 0xb2, 0xb9, 0x5e, 0x5d, 0x69,
	0x1c, 0x04, 0x82, 0xb7, 0x07, 0x74, 0xc8, 0x66, 0x77, 0x5b, 0x06, 0xe3, 0x29, 0xc0, 0xf5, 0x2a,
	0xe2, 0xe9, 0x20, 0x10, 0x2d, 0x5b, 0xa7, 0xc3, 0xe2, 0xbc, 0xf2, 0xc5, 0x2b, 0x83, 0xd0, 0xaf,
	0xa1, 0x85, 0x1e, 0x34, 0x0d, 0x63, 0x0a, 0xcd, 0x4d, 0x0d, 0x0a, 0x32, 0xfb, 0x96, 0x65, 0x63,
	0x35, 0x9c, 0x81, 0x39, 0xe6, 0x7e, 0x0a, 0x0d, 0xf5, 0x15, 0xc6, 0x05, 0xeb, 0xcd, 0xe9, 0xc4,
	0x21, 0x7a, 0x54, 0x2a, 0x40, 0x9c, 0x95, 0xe4, 0xaf, 0x4e, 0x2e, 0x6a, 0xab, 0xc0, 0x7a, 0xe3,
	0x57, 0xe7, 0x3b, 0x03, 0xb4, 0x6a, 0x4b, 0xcb, 0xbb, 0x63, 0xe2, 0x41, 0x4b, 0xc7, 0x58, 0xfe,
	0x13, 0x4b, 0x5e, 0x91, 0xe9, 0x2f, 0x53, 0x5b, 0xf1, 0x54, 0x40, 0x66, 0xa1, 0x5b, 0x36, 0xae,
	0xd7, 0x4c, 0x0d, 0x3d, 0x3c, 0x73, 0xd2, 0x90, 0xcb, 0xdb, 0xd8, 0x9e, 0x9e, 0xfd, 0xcc, 0x33,
	0xa7, 0x81, 0xda, 0x67, 0x4e, 0x0d, 0x74, 0xc7, 0xe4, 0xbe, 0xe9, 0x85, 0xe6, 0xea, 0xae, 0xd5,
	0xb8, 0x1c, 0x35, 0x51, 0xd3, 0xb6, 0x83, 0x11, 0xe5, 0xd1, 0xac, 0x89, 0xc2, 0x7c, 0x44, 0x0d,
	0xd0, 0xf5, 0x80, 0x47, 0x45, 0x5f, 0x7d, 0x0b, 0xaa, 0x59, 0x1e, 0xa7, 0x82, 0x4a, 0x1b, 0xb8,
	0xea, 0xe6, 0x74, 0xe2, 0xd4, 0xa4, 0xd1, 0x5d, 0x71, 0xb0, 0x95, 0x20, 0xf9, 0x08, 0x96, 0x69,
	0xda, 0x3f, 0xe7, 0x17, 0xcc, 0x57, 0x54, 0xde, 0xbc, 0x44, 0xbd, 0xa5, 0x74, 0xbe, 0x92, 0xfc,
	0x7e, 0x17, 0x1a, 0x09, 0xed, 0x3f, 0xa7, 0x03, 0xe6, 0x8f, 0xd2, 0x50, 0x5d, 0x83, 0xd9, 0x16,
	0xa0, 0x14, 0x9e, 0xa5, 0x21, 0x79, 0x04, 0x35, 0xf5, 0x2b, 0xc3, 0xb1, 0xd2, 0x6e, 0xf2, 0x6a,
	0x67, 0x76, 0x8e, 0x95, 0x8a, 0x2c, 0x4c, 0xdb, 0x5b, 0x61, 0xbf, 0xf1, 0x00, 0x5a, 0x96, 0xe2,
	0x95, 0xea, 0xf2, 0x1f, 0x0b, 0xd0, 0x78, 0x96, 0x88, 0x51, 0xeb, 0x24, 0x7e, 0xce, 0x22, 0xf2,
	0x21, 0x94, 0x73, 0xf1, 0xa0, 0x4a, 0xd2, 0x38, 0x83, 0xa0, 0xd8, 0xba, 0xd1, 0x40, 0x89, 0xa0,
	0x37, 0xf6, 0x32, 0xe1, 0x29, 0xcb, 0x8a, 0x1b, 0x17, 0x93, 0xde, 0x66, 0x98, 0x45, 0x6f, 0x4a,
	0xdc, 0xc9, 0xc5, 0xdc, 0x3b, 0xca, 0xcc, 0x06, 0x60, 0xcc, 0xbd, 0x0a, 0xb0, 0xe6, 0x5e, 0x21,
	0x3b, 0x08, 0x84, 0x99, 0x66, 0x84, 0xa5, 0x79, 0x33, 0x05, 0xd8, 0x77, 0xbd, 0x92, 0x1b, 0x3a,
	0xd0, 0x88, 0xd8, 0x8b, 0x22, 0x7b, 0xca, 0xf3, 0x65, 0x65, 0x80, 0x56, 0x59, 0x45, 0xec, 0xc5,
	0x69, 0x71, 0x72, 0xaa, 0x8f, 0x30, 0x62, 0x7e, 0x1e, 0xab, 0xba, 0x34, 0x8e, 0x87, 0x05, 0x64,
	0x4d, 0xf9, 0x23, 0x15, 0xe2, 0x77, 0xdf, 0x83, 0x8a, 0xbc, 0x9a, 0x26, 0x0d, 0xa8, 0x3e, 0x3b,
	0xfc, 0xfa, 0xf0, 0xe8, 0x9b, 0xc3, 0xd5, 0x6b, 0xa4, 0x06, 0x4b, 0x4f, 0x3a, 0x8f, 0xf7, 0x57,
	0x4b, 0x04, 0xa0, 0xf2, 0xd5, 0x3e, 0x3e, 0x2f, 0xbc, 0x7b, 0x06, 0x4d, 0xb3, 0x48, 0x85, 0xc9,
	0xae, 0xb7, 0xdf, 0x39, 0xd9, 0xdf, 0x5b, 0xbd, 0x46, 0x56, 0xa0, 0xb1, 0xb7, 0x7f, 0xba, 0xff,
	0xf8, 0xe8, 0xf8, 0xc9, 0xfe, 0xe1, 0xc9, 0x6a, 0x49, 0xa0, 0xdf, 0x74, 0x0e, 0x4e, 0x0e, 0x0e,
	0x1f, 0xae, 0x2e, 0x90, 0x26, 0xd4, 0xbc, 0xfd, 0x47, 0xfb, 0xbb, 0x42, 0x77, 0x91, 0xb4, 0xa0,
	0x7e, 0xda, 0x79, 0x7c, 0xb0, 0x87, 0xa6, 0x4b, 0x64, 0x19, 0xe0, 0xd8, 0x3b, 0xda, 0x7b, 0xb6,
	0x7b, 0x72, 0x70, 0x74, 0xb8, 0x5a, 0xee, 0x7e, 0xfa, 0xdd, 0xdf, 0x37, 0xaf, 0x7d, 0xf7, 0xc3,
	0x66, 0xe9, 0xaf, 0x3f, 0x6c, 0x96, 0xfe, 0xf6, 0xc3, 0x66, 0xe9, 0x0f, 0x3f, 0x6e, 0x5e, 0x83,
	0x95, 0x7e, 0x3c, 0xdc, 0x89, 0xf3, 0x8c, 0x0f, 0xe3, 0x9d, 0x41, 0x9a, 0xf4, 0x8f, 0x4b, 0xff,
	0x5f, 0x93, 0x3f, 0x93, 0xde, 0x9f, 0x16, 0x16, 0x8f, 0x4e, 0x9e, 0xfe, 0xdf, 0xb5, 0x5e, 0x05,
	0xff, 0x5d, 0xff, 0xd1, 0xbf, 0x02, 0x00, 0x00, 0xff, 0xff, 0x33, 0x26, 0xfa, 0x30, 0xdb, 0x1f,
	0x00, 0x00,
}

func (m *Address) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Address) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.StreetAddress) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.StreetAddress)))
		i += copy(dAtA[i:], m.StreetAddress)
	}
	if len(m.City) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.City)))
		i += copy(dAtA[i:], m.City)
	}
	if len(m.State) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if len(m.ZipCode) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.ZipCode)))
		i += copy(dAtA[i:], m.ZipCode)
	}
	if len(m.CountryCode) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.CountryCode)))
		i += copy(dAtA[i:], m.CountryCode)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Profile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Profile) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Email) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.Email)))
		i += copy(dAtA[i:], m.Email)
	}
	if len(m.FirstName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.FirstName)))
		i += copy(dAtA[i:], m.FirstName)
	}
	if len(m.LastName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.LastName)))
		i += copy(dAtA[i:], m.LastName)
	}
	if len(m.Language) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.Language)))
		i += copy(dAtA[i:], m.Language)
	}
	if len(m.MobilePhone) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.MobilePhone)))
		i += copy(dAtA[i:], m.MobilePhone)
	}
	if m.Address != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintModels(dAtA, i, uint64(m.Address.Size()))
		n1, err1 := m.Address.MarshalTo(dAtA[i:])
		if err1 != nil {
			return 0, err1
		}
		i += n1
	}
	if m.CreatedAt != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintModels(dAtA, i, uint64(m.CreatedAt))
	}
	if m.LastUpdated != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintModels(dAtA, i, uint64(m.LastUpdated))
	}
	if len(m.Locale) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.Locale)))
		i += copy(dAtA[i:], m.Locale)
	}
	if m.Timezone != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintModels(dAtA, i, uint64(m.Timezone))
	}
	if len(m.Country) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.Country)))
		i += copy(dAtA[i:], m.Country)
	}
	if len(m.Labels) > 0 {
		for k, _ := range m.Labels {
			dAtA[i] = 0x6a
			i++
			v := m.Labels[k]
			mapSize := 1 + len(k) + sovModels(uint64(len(k))) + 1 + len(v) + sovModels(uint64(len(v)))
			i = encodeVarintModels(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintModels(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintModels(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ChildGameEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChildGameEntry) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.Active {
		dAtA[i] = 0x10
		i++
		if m.Active {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.DashboardIndex != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintModels(dAtA, i, uint64(m.DashboardIndex))
	}
	if len(m.Settings) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.Settings)))
		i += copy(dAtA[i:], m.Settings)
	}
	if m.AddedAt != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintModels(dAtA, i, uint64(m.AddedAt))
	}
	if m.ActivationChangedAt != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintModels(dAtA, i, uint64(m.ActivationChangedAt))
	}
	if m.UpdatedAt != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintModels(dAtA, i, uint64(m.UpdatedAt))
	}
	if len(m.LocalSettings) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.LocalSettings)))
		i += copy(dAtA[i:], m.LocalSettings)
	}
	if m.LocalSettingsVersion != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintModels(dAtA, i, uint64(m.LocalSettingsVersion))
	}
	if len(m.LimitAccess) > 0 {
		for _, s := range m.LimitAccess {
			dAtA[i] = 0x52
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Child) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Child) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.ParentId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.ParentId)))
		i += copy(dAtA[i:], m.ParentId)
	}
	if len(m.FirstName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.FirstName)))
		i += copy(dAtA[i:], m.FirstName)
	}
	if len(m.LastName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.LastName)))
		i += copy(dAtA[i:], m.LastName)
	}
	if m.BirthDay != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintModels(dAtA, i, uint64(m.BirthDay))
	}
	if m.Gender != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintModels(dAtA, i, uint64(m.Gender))
	}
	if len(m.Language) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.Language)))
		i += copy(dAtA[i:], m.Language)
	}
	if len(m.Games) > 0 {
		for _, msg := range m.Games {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintModels(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Active {
		dAtA[i] = 0x50
		i++
		if m.Active {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LoggedIn {
		dAtA[i] = 0x58
		i++
		if m.LoggedIn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SoundsEnabled {
		dAtA[i] = 0x60
		i++
		if m.SoundsEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Locale) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.Locale)))
		i += copy(dAtA[i:], m.Locale)
	}
	if m.CreatedAt != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintModels(dAtA, i, uint64(m.CreatedAt))
	}
	if m.LastUpdated != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintModels(dAtA, i, uint64(m.LastUpdated))
	}
	if len(m.ChildInfo) > 0 {
		for k, _ := range m.ChildInfo {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x1
			i++
			v := m.ChildInfo[k]
			mapSize := 1 + len(k) + sovModels(uint64(len(k))) + 1 + len(v) + sovModels(uint64(len(v)))
			i = encodeVarintModels(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintModels(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintModels(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.TotalStarCount != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintModels(dAtA, i, uint64(m.TotalStarCount))
	}
	if m.LevelStarCount != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintModels(dAtA, i, uint64(m.LevelStarCount))
	}
	if m.Level != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintModels(dAtA, i, uint64(m.Level))
	}
	if len(m.Badges) > 0 {
		for _, msg := range m.Badges {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintModels(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Badge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Badge) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.CreatedAt != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintModels(dAtA, i, uint64(m.CreatedAt))
	}
	if m.Level != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintModels(dAtA, i, uint64(m.Level))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Author) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Author) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Email) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.Email)))
		i += copy(dAtA[i:], m.Email)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GameMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameMetadata) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Language) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.Language)))
		i += copy(dAtA[i:], m.Language)
	}
	if len(m.VisibleName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.VisibleName)))
		i += copy(dAtA[i:], m.VisibleName)
	}
	if len(m.Summary) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.Summary)))
		i += copy(dAtA[i:], m.Summary)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.Logo) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.Logo)))
		i += copy(dAtA[i:], m.Logo)
	}
	if len(m.Icon) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.Icon)))
		i += copy(dAtA[i:], m.Icon)
	}
	if len(m.Keywords) > 0 {
		for _, s := range m.Keywords {
			dAtA[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Images) > 0 {
		for _, s := range m.Images {
			dAtA[i] = 0x42
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.InfoSlug) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.InfoSlug)))
		i += copy(dAtA[i:], m.InfoSlug)
	}
	if len(m.Assets) > 0 {
		for _, s := range m.Assets {
			dAtA[i] = 0x52
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Annotations) > 0 {
		for k, _ := range m.Annotations {
			dAtA[i] = 0x5a
			i++
			v := m.Annotations[k]
			mapSize := 1 + len(k) + sovModels(uint64(len(k))) + 1 + len(v) + sovModels(uint64(len(v)))
			i = encodeVarintModels(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintModels(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintModels(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GameManifest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameManifest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UniqueName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.UniqueName)))
		i += copy(dAtA[i:], m.UniqueName)
	}
	if len(m.Licence) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.Licence)))
		i += copy(dAtA[i:], m.Licence)
	}
	if len(m.Languages) > 0 {
		for _, s := range m.Languages {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Homepage) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.Homepage)))
		i += copy(dAtA[i:], m.Homepage)
	}
	if len(m.Main) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.Main)))
		i += copy(dAtA[i:], m.Main)
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if len(m.Authors) > 0 {
		for _, msg := range m.Authors {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintModels(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Repository) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.Repository)))
		i += copy(dAtA[i:], m.Repository)
	}
	if len(m.SupportedOrientations) > 0 {
		for _, s := range m.SupportedOrientations {
			dAtA[i] = 0x4a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Metadata) > 0 {
		for _, msg := range m.Metadata {
			dAtA[i] = 0x6a
			i++
			i = encodeVarintModels(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Exclude) > 0 {
		for _, s := range m.Exclude {
			dAtA[i] = 0x72
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Settings) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.Settings)))
		i += copy(dAtA[i:], m.Settings)
	}
	if len(m.KvPath) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.KvPath)))
		i += copy(dAtA[i:], m.KvPath)
	}
	if len(m.DeveloperName) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.DeveloperName)))
		i += copy(dAtA[i:], m.DeveloperName)
	}
	if len(m.DefaultLanguage) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.DefaultLanguage)))
		i += copy(dAtA[i:], m.DefaultLanguage)
	}
	if len(m.LoadingColor) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.LoadingColor)))
		i += copy(dAtA[i:], m.LoadingColor)
	}
	if len(m.Capabilities) > 0 {
		for _, s := range m.Capabilities {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.AbTest) > 0 {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.AbTest)))
		i += copy(dAtA[i:], m.AbTest)
	}
	if len(m.Labels) > 0 {
		for k, _ := range m.Labels {
			dAtA[i] = 0xb2
			i++
			dAtA[i] = 0x1
			i++
			v := m.Labels[k]
			mapSize := 1 + len(k) + sovModels(uint64(len(k))) + 1 + len(v) + sovModels(uint64(len(v)))
			i = encodeVarintModels(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintModels(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintModels(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.ManifestVersion != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintModels(dAtA, i, uint64(m.ManifestVersion))
	}
	if len(m.Options) > 0 {
		for k, _ := range m.Options {
			dAtA[i] = 0xc2
			i++
			dAtA[i] = 0x1
			i++
			v := m.Options[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovModels(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovModels(uint64(len(k))) + msgSize
			i = encodeVarintModels(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintModels(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintModels(dAtA, i, uint64(v.Size()))
				n2, err2 := v.MarshalTo(dAtA[i:])
				if err2 != nil {
					return 0, err2
				}
				i += n2
			}
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GameEnumGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameEnumGroup) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.DefaultValue) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.DefaultValue)))
		i += copy(dAtA[i:], m.DefaultValue)
	}
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GameOption) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameOption) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Type) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.Default) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.Default)))
		i += copy(dAtA[i:], m.Default)
	}
	if len(m.Enum) > 0 {
		for _, s := range m.Enum {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Format) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.Format)))
		i += copy(dAtA[i:], m.Format)
	}
	if m.MinValue != 0 {
		dAtA[i] = 0x39
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MinValue))))
		i += 8
	}
	if m.MaxValue != 0 {
		dAtA[i] = 0x41
		i++
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.MaxValue))))
		i += 8
	}
	if len(m.Image) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.Image)))
		i += copy(dAtA[i:], m.Image)
	}
	if len(m.SortKey) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.SortKey)))
		i += copy(dAtA[i:], m.SortKey)
	}
	if len(m.EnumGroups) > 0 {
		for _, msg := range m.EnumGroups {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintModels(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Game) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Game) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.UniqueName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.UniqueName)))
		i += copy(dAtA[i:], m.UniqueName)
	}
	if len(m.OwnerId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.OwnerId)))
		i += copy(dAtA[i:], m.OwnerId)
	}
	if len(m.ProductionVersion) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.ProductionVersion)))
		i += copy(dAtA[i:], m.ProductionVersion)
	}
	if m.IsOnProduction {
		dAtA[i] = 0x28
		i++
		if m.IsOnProduction {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CreatedAt != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintModels(dAtA, i, uint64(m.CreatedAt))
	}
	if m.LastUpdated != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintModels(dAtA, i, uint64(m.LastUpdated))
	}
	if len(m.Labels) > 0 {
		for k, _ := range m.Labels {
			dAtA[i] = 0x42
			i++
			v := m.Labels[k]
			mapSize := 1 + len(k) + sovModels(uint64(len(k))) + 1 + len(v) + sovModels(uint64(len(v)))
			i = encodeVarintModels(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintModels(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintModels(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GameRelease) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameRelease) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ReleaseId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.ReleaseId)))
		i += copy(dAtA[i:], m.ReleaseId)
	}
	if len(m.GameId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.GameId)))
		i += copy(dAtA[i:], m.GameId)
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if m.GameManifest != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintModels(dAtA, i, uint64(m.GameManifest.Size()))
		n3, err3 := m.GameManifest.MarshalTo(dAtA[i:])
		if err3 != nil {
			return 0, err3
		}
		i += n3
	}
	if m.ReleasedAt != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintModels(dAtA, i, uint64(m.ReleasedAt))
	}
	if len(m.ReleasedBy) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.ReleasedBy)))
		i += copy(dAtA[i:], m.ReleasedBy)
	}
	if m.ReleaseState != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintModels(dAtA, i, uint64(m.ReleaseState))
	}
	if len(m.ValidatedBy) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.ValidatedBy)))
		i += copy(dAtA[i:], m.ValidatedBy)
	}
	if m.ValidatedAt != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintModels(dAtA, i, uint64(m.ValidatedAt))
	}
	if m.IntVersion != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintModels(dAtA, i, uint64(m.IntVersion))
	}
	if len(m.Storage) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.Storage)))
		i += copy(dAtA[i:], m.Storage)
	}
	if len(m.ArchiveFormat) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.ArchiveFormat)))
		i += copy(dAtA[i:], m.ArchiveFormat)
	}
	if len(m.PackageUrl) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.PackageUrl)))
		i += copy(dAtA[i:], m.PackageUrl)
	}
	if len(m.Packages) > 0 {
		for k, _ := range m.Packages {
			dAtA[i] = 0x72
			i++
			v := m.Packages[k]
			mapSize := 1 + len(k) + sovModels(uint64(len(k))) + 1 + len(v) + sovModels(uint64(len(v)))
			i = encodeVarintModels(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintModels(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintModels(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UploadToken) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadToken) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Token) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.Token)))
		i += copy(dAtA[i:], m.Token)
	}
	if m.ExpiresAt != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintModels(dAtA, i, uint64(m.ExpiresAt))
	}
	if len(m.UserId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.UserId)))
		i += copy(dAtA[i:], m.UserId)
	}
	if len(m.GameId) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.GameId)))
		i += copy(dAtA[i:], m.GameId)
	}
	if len(m.NewVersion) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.NewVersion)))
		i += copy(dAtA[i:], m.NewVersion)
	}
	if len(m.UploadTo) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintModels(dAtA, i, uint64(len(m.UploadTo)))
		i += copy(dAtA[i:], m.UploadTo)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintModels(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Address) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StreetAddress)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.City)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.ZipCode)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.CountryCode)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Profile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.FirstName)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.LastName)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.Language)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.MobilePhone)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Address != nil {
		l = m.Address.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	if m.CreatedAt != 0 {
		n += 1 + sovModels(uint64(m.CreatedAt))
	}
	if m.LastUpdated != 0 {
		n += 1 + sovModels(uint64(m.LastUpdated))
	}
	l = len(m.Locale)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Timezone != 0 {
		n += 1 + sovModels(uint64(m.Timezone))
	}
	l = len(m.Country)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovModels(uint64(len(k))) + 1 + len(v) + sovModels(uint64(len(v)))
			n += mapEntrySize + 1 + sovModels(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChildGameEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.Active {
		n += 2
	}
	if m.DashboardIndex != 0 {
		n += 1 + sovModels(uint64(m.DashboardIndex))
	}
	l = len(m.Settings)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.AddedAt != 0 {
		n += 1 + sovModels(uint64(m.AddedAt))
	}
	if m.ActivationChangedAt != 0 {
		n += 1 + sovModels(uint64(m.ActivationChangedAt))
	}
	if m.UpdatedAt != 0 {
		n += 1 + sovModels(uint64(m.UpdatedAt))
	}
	l = len(m.LocalSettings)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.LocalSettingsVersion != 0 {
		n += 1 + sovModels(uint64(m.LocalSettingsVersion))
	}
	if len(m.LimitAccess) > 0 {
		for _, s := range m.LimitAccess {
			l = len(s)
			n += 1 + l + sovModels(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Child) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.ParentId)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.FirstName)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.LastName)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.BirthDay != 0 {
		n += 1 + sovModels(uint64(m.BirthDay))
	}
	if m.Gender != 0 {
		n += 1 + sovModels(uint64(m.Gender))
	}
	l = len(m.Language)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if len(m.Games) > 0 {
		for _, e := range m.Games {
			l = e.Size()
			n += 1 + l + sovModels(uint64(l))
		}
	}
	if m.Active {
		n += 2
	}
	if m.LoggedIn {
		n += 2
	}
	if m.SoundsEnabled {
		n += 2
	}
	l = len(m.Locale)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.CreatedAt != 0 {
		n += 1 + sovModels(uint64(m.CreatedAt))
	}
	if m.LastUpdated != 0 {
		n += 2 + sovModels(uint64(m.LastUpdated))
	}
	if len(m.ChildInfo) > 0 {
		for k, v := range m.ChildInfo {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovModels(uint64(len(k))) + 1 + len(v) + sovModels(uint64(len(v)))
			n += mapEntrySize + 2 + sovModels(uint64(mapEntrySize))
		}
	}
	if m.TotalStarCount != 0 {
		n += 2 + sovModels(uint64(m.TotalStarCount))
	}
	if m.LevelStarCount != 0 {
		n += 2 + sovModels(uint64(m.LevelStarCount))
	}
	if m.Level != 0 {
		n += 2 + sovModels(uint64(m.Level))
	}
	if len(m.Badges) > 0 {
		for _, e := range m.Badges {
			l = e.Size()
			n += 2 + l + sovModels(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Badge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.CreatedAt != 0 {
		n += 1 + sovModels(uint64(m.CreatedAt))
	}
	if m.Level != 0 {
		n += 1 + sovModels(uint64(m.Level))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Author) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GameMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Language)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.VisibleName)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.Summary)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.Logo)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.Icon)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if len(m.Keywords) > 0 {
		for _, s := range m.Keywords {
			l = len(s)
			n += 1 + l + sovModels(uint64(l))
		}
	}
	if len(m.Images) > 0 {
		for _, s := range m.Images {
			l = len(s)
			n += 1 + l + sovModels(uint64(l))
		}
	}
	l = len(m.InfoSlug)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if len(m.Assets) > 0 {
		for _, s := range m.Assets {
			l = len(s)
			n += 1 + l + sovModels(uint64(l))
		}
	}
	if len(m.Annotations) > 0 {
		for k, v := range m.Annotations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovModels(uint64(len(k))) + 1 + len(v) + sovModels(uint64(len(v)))
			n += mapEntrySize + 1 + sovModels(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GameManifest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UniqueName)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.Licence)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if len(m.Languages) > 0 {
		for _, s := range m.Languages {
			l = len(s)
			n += 1 + l + sovModels(uint64(l))
		}
	}
	l = len(m.Homepage)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.Main)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if len(m.Authors) > 0 {
		for _, e := range m.Authors {
			l = e.Size()
			n += 1 + l + sovModels(uint64(l))
		}
	}
	l = len(m.Repository)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if len(m.SupportedOrientations) > 0 {
		for _, s := range m.SupportedOrientations {
			l = len(s)
			n += 1 + l + sovModels(uint64(l))
		}
	}
	if len(m.Metadata) > 0 {
		for _, e := range m.Metadata {
			l = e.Size()
			n += 1 + l + sovModels(uint64(l))
		}
	}
	if len(m.Exclude) > 0 {
		for _, s := range m.Exclude {
			l = len(s)
			n += 1 + l + sovModels(uint64(l))
		}
	}
	l = len(m.Settings)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.KvPath)
	if l > 0 {
		n += 2 + l + sovModels(uint64(l))
	}
	l = len(m.DeveloperName)
	if l > 0 {
		n += 2 + l + sovModels(uint64(l))
	}
	l = len(m.DefaultLanguage)
	if l > 0 {
		n += 2 + l + sovModels(uint64(l))
	}
	l = len(m.LoadingColor)
	if l > 0 {
		n += 2 + l + sovModels(uint64(l))
	}
	if len(m.Capabilities) > 0 {
		for _, s := range m.Capabilities {
			l = len(s)
			n += 2 + l + sovModels(uint64(l))
		}
	}
	l = len(m.AbTest)
	if l > 0 {
		n += 2 + l + sovModels(uint64(l))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovModels(uint64(len(k))) + 1 + len(v) + sovModels(uint64(len(v)))
			n += mapEntrySize + 2 + sovModels(uint64(mapEntrySize))
		}
	}
	if m.ManifestVersion != 0 {
		n += 2 + sovModels(uint64(m.ManifestVersion))
	}
	if len(m.Options) > 0 {
		for k, v := range m.Options {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovModels(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovModels(uint64(len(k))) + l
			n += mapEntrySize + 2 + sovModels(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GameEnumGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.DefaultValue)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			l = len(s)
			n += 1 + l + sovModels(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GameOption) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.Default)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if len(m.Enum) > 0 {
		for _, s := range m.Enum {
			l = len(s)
			n += 1 + l + sovModels(uint64(l))
		}
	}
	l = len(m.Format)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.MinValue != 0 {
		n += 9
	}
	if m.MaxValue != 0 {
		n += 9
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.SortKey)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if len(m.EnumGroups) > 0 {
		for _, e := range m.EnumGroups {
			l = e.Size()
			n += 1 + l + sovModels(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Game) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.UniqueName)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.OwnerId)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.ProductionVersion)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.IsOnProduction {
		n += 2
	}
	if m.CreatedAt != 0 {
		n += 1 + sovModels(uint64(m.CreatedAt))
	}
	if m.LastUpdated != 0 {
		n += 1 + sovModels(uint64(m.LastUpdated))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovModels(uint64(len(k))) + 1 + len(v) + sovModels(uint64(len(v)))
			n += mapEntrySize + 1 + sovModels(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GameRelease) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ReleaseId)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.GameId)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.GameManifest != nil {
		l = m.GameManifest.Size()
		n += 1 + l + sovModels(uint64(l))
	}
	if m.ReleasedAt != 0 {
		n += 1 + sovModels(uint64(m.ReleasedAt))
	}
	l = len(m.ReleasedBy)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.ReleaseState != 0 {
		n += 1 + sovModels(uint64(m.ReleaseState))
	}
	l = len(m.ValidatedBy)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.ValidatedAt != 0 {
		n += 1 + sovModels(uint64(m.ValidatedAt))
	}
	if m.IntVersion != 0 {
		n += 1 + sovModels(uint64(m.IntVersion))
	}
	l = len(m.Storage)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.ArchiveFormat)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.PackageUrl)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if len(m.Packages) > 0 {
		for k, v := range m.Packages {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovModels(uint64(len(k))) + 1 + len(v) + sovModels(uint64(len(v)))
			n += mapEntrySize + 1 + sovModels(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UploadToken) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.ExpiresAt != 0 {
		n += 1 + sovModels(uint64(m.ExpiresAt))
	}
	l = len(m.UserId)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.GameId)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.NewVersion)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	l = len(m.UploadTo)
	if l > 0 {
		n += 1 + l + sovModels(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovModels(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozModels(x uint64) (n int) {
	return sovModels(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Address) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Address: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Address: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreetAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StreetAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field City", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.City = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZipCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ZipCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountryCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CountryCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Profile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Profile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Profile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MobilePhone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MobilePhone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Address == nil {
				m.Address = &Address{}
			}
			if err := m.Address.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdated", wireType)
			}
			m.LastUpdated = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastUpdated |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locale", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Locale = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timezone", wireType)
			}
			m.Timezone = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timezone |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Country", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Country = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModels
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModels
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthModels
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthModels
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModels
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthModels
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthModels
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipModels(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthModels
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChildGameEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChildGameEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChildGameEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Active = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DashboardIndex", wireType)
			}
			m.DashboardIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DashboardIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Settings", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Settings = append(m.Settings[:0], dAtA[iNdEx:postIndex]...)
			if m.Settings == nil {
				m.Settings = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddedAt", wireType)
			}
			m.AddedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivationChangedAt", wireType)
			}
			m.ActivationChangedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActivationChangedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			m.UpdatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalSettings", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalSettings = append(m.LocalSettings[:0], dAtA[iNdEx:postIndex]...)
			if m.LocalSettings == nil {
				m.LocalSettings = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalSettingsVersion", wireType)
			}
			m.LocalSettingsVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocalSettingsVersion |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitAccess", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LimitAccess = append(m.LimitAccess, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Child) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Child: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Child: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BirthDay", wireType)
			}
			m.BirthDay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BirthDay |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gender", wireType)
			}
			m.Gender = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gender |= Gender(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Games", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Games = append(m.Games, &ChildGameEntry{})
			if err := m.Games[len(m.Games)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Active = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoggedIn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LoggedIn = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SoundsEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SoundsEnabled = bool(v != 0)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locale", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Locale = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdated", wireType)
			}
			m.LastUpdated = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastUpdated |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChildInfo == nil {
				m.ChildInfo = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModels
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModels
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthModels
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthModels
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModels
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthModels
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthModels
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipModels(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthModels
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ChildInfo[mapkey] = mapvalue
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalStarCount", wireType)
			}
			m.TotalStarCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalStarCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LevelStarCount", wireType)
			}
			m.LevelStarCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LevelStarCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Badges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Badges = append(m.Badges, &Badge{})
			if err := m.Badges[len(m.Badges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Badge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Badge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Badge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Author) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Author: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Author: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VisibleName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VisibleName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Summary", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Summary = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Logo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Logo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keywords", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keywords = append(m.Keywords, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Images", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Images = append(m.Images, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfoSlug", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InfoSlug = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assets", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Assets = append(m.Assets, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModels
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModels
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthModels
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthModels
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModels
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthModels
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthModels
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipModels(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthModels
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Annotations[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameManifest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameManifest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameManifest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UniqueName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Licence", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Licence = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Languages", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Languages = append(m.Languages, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Homepage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Homepage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Main", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Main = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authors = append(m.Authors, &Author{})
			if err := m.Authors[len(m.Authors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repository", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Repository = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportedOrientations", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SupportedOrientations = append(m.SupportedOrientations, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = append(m.Metadata, &GameMetadata{})
			if err := m.Metadata[len(m.Metadata)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exclude", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Exclude = append(m.Exclude, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Settings", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Settings = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KvPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KvPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeveloperName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeveloperName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultLanguage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultLanguage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadingColor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LoadingColor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capabilities", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Capabilities = append(m.Capabilities, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbTest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AbTest = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModels
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModels
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthModels
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthModels
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModels
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthModels
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthModels
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipModels(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthModels
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManifestVersion", wireType)
			}
			m.ManifestVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ManifestVersion |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = make(map[string]*GameOption)
			}
			var mapkey string
			var mapvalue *GameOption
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModels
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModels
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthModels
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthModels
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModels
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthModels
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthModels
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &GameOption{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipModels(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthModels
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Options[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameEnumGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameEnumGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameEnumGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameOption) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameOption: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameOption: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Default", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Default = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Enum = append(m.Enum, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Format = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinValue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MinValue = float64(math.Float64frombits(v))
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxValue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.MaxValue = float64(math.Float64frombits(v))
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SortKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SortKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnumGroups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EnumGroups = append(m.EnumGroups, &GameEnumGroup{})
			if err := m.EnumGroups[len(m.EnumGroups)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Game) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Game: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Game: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UniqueName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductionVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductionVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsOnProduction", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsOnProduction = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdated", wireType)
			}
			m.LastUpdated = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastUpdated |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModels
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModels
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthModels
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthModels
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModels
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthModels
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthModels
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipModels(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthModels
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameRelease) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameRelease: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameRelease: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReleaseId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReleaseId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GameId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameManifest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GameManifest == nil {
				m.GameManifest = &GameManifest{}
			}
			if err := m.GameManifest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReleasedAt", wireType)
			}
			m.ReleasedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReleasedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReleasedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReleasedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReleaseState", wireType)
			}
			m.ReleaseState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReleaseState |= ReleaseState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatedAt", wireType)
			}
			m.ValidatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntVersion", wireType)
			}
			m.IntVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IntVersion |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Storage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Storage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArchiveFormat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ArchiveFormat = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackageUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PackageUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Packages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Packages == nil {
				m.Packages = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModels
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModels
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthModels
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthModels
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModels
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthModels
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthModels
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipModels(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthModels
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Packages[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadToken) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModels
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadToken: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadToken: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiresAt", wireType)
			}
			m.ExpiresAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiresAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GameId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadTo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModels
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModels
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModels
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UploadTo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModels(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModels
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipModels(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowModels
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModels
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModels
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthModels
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthModels
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowModels
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipModels(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthModels
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthModels = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowModels   = fmt.Errorf("proto: integer overflow")
)
